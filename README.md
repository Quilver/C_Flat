# C_Flat
This is a project which transpiles our language (C_Flat) into C#. The transpiler is written in C# with a WPF GUI. 
You can find a markdown file detailing the C_Flat language definition in `C_Flat_Definition.md`

## Getting Started

### Clone github repository and open in your IDE of choice (I recommend JetBrains Rider)

To clone the repository, you can run the command below from a shell window (e.g. cmd or git bash) to clone the repository.
If you don't have git installed you can follow this guide: https://git-scm.com/book/en/v2/Getting-Started-Installing-Git

```sh
git clone git@github.com:UEA-advanced-programmers/C_Flat.git
```

If you opt to use Github Desktop instead you can do so:
Go to the repository page, click 'Code' -> 'Open with GitHub desktop' -> clone

Once you've cloned the rpeository, you should be able to open the project in your IDE of choice.

## Solution Structure:
### Overall description
In this solution there are 4 projects: `C_Flat_GUI`, `C_Flat_Interpreter`, `C_Flat_Tests` and `C_Flat_Output`. Each being used as their name suggests, due to WPF only supporting Windows, it is better to store the majority of the non-GUI code in a regular .NET6 project. Which allows for compilation and subsequent Continuous Integration, on other platforms such as Linux (Which is used by GitHub Actions for automated testing).  

### GUI Project
`C_Flat_GUI` is a Windows Presentation Foundation (WPF) project targeting `.Net6.0-windows`. Due to the W in WPF this project ***only*** supports compilation on/for Windows. The project will house the front-end GUI code for our solution and will rely on the 'Interpreter` project for the back-end.

### Interpreter Project
`C_Flat_Interpreter` is a class library project which will house the back-end code for our solution. The interpreter will be split up into lexing, parsing and transpiling the C_Flat code provided to it by the GUI. As it is a class library it will not compile an executable* however, the written code will be tested by the final of the three projects.

<sub>* ~~Whilst we want the interpreter project to stay as a standalone class-library, to compile the parsed code into valid C# we may have to resort to creating an executable for this project but this is subject to change.~~ 
We have kept interpreter as a class library, instead creating a new project for handling the transpiled output, aptly named `C_Flat_Output` </sub>

### Test Project
`C_Flat_Tests` is a test project which uses NUnit Framework to test the code within the interpreter project. 
The benefit of separating the tests into their own project, is that it allows us to use tools such as `dotnet test` to automate testing which will prevent bugs from entering the project. 
This can be facilitated using GitHub Actions, through requiring all tests within the solution to pass before a Pull Request can merge.
For a comprehensive explanation of our testing conventions see `C_Flat_Tests/Testing.md`.
This includes a break down of naming conventions, test structures, etc.

### Output Project:
`C_Flat_Output` is a .NET 6 console application project which contains only one C# file `Program.cs`. 
The purpose of this file is to store the C# code generated by the transpile pipeline. This project can be run through either the IDE or by running the `dotnet run C_Flat_Output/` command.
This will execute whatever code is currently stored within `Program.cs`, also logging any potential compilation errors if it contains invalid syntax.

## Review Process:
The process for getting completed features into the main branch of C_Flat is as follows:

1. Work is completed on the members development branch e.g. `Kiall-Dev-Branch`
2. Once the member feels they are ready to merge they open a pull request on GitHub targeting `main`
3. This kicks off the automated test runners mentioned above.
4. In order to merge the PR must both pass the automated tests **and** receive approval in the form of a review from another group member
5. If there are any changes requested by reviewers or tests fail, the member continues iterating on the branch, and re-requests a review when they once again feel ready to merge
6. Every time a new commit is pushed to the branch in question, the tests are automatically re-ran and all previous approvals are dismissed.
7. Once everything passes and is approved the member can merge their pull request and continue working on their development branch
